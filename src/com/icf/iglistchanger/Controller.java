package com.icf.iglistchanger;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

import org.json.JSONArray;
import org.json.JSONObject;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

/**
 * This is the workhorse class for the IGListChanger application. It reads a table-descriptor org.jsoup.nodes.Element from a list of table-descriptors (as read from an xml control  file), and
 * processes the descriptor. The result of processing a table-descriptor is an altered html table element in an html file.
 * 
 * <p>An example of a control file containing a single table-descriptor:</p>
 * 
 * <pre>
 * {@code
 *       <table-descriptors>
 * 		    <table-descriptor>
 * 		        <generatedHTMLFile>C:\ICF-work\Dev\Measures\Ecqm-content-r4-2021\git-myFork\ecqm-content-r4-2021\output\measures.html</generated>
 * 		        <outputHTMLFile>measures-new.html</outputHTMLFile>
 * 		        <targetTablePos>0</targetTablePos>
 * 		        <resourceDirectory>C:\ICF-work\Dev\Measures\Ecqm-content-r4-2021\git-myFork\ecqm-content-r4-2021\input\resources\measure</resourceDirectory>
 * 		        <oldColumn oldPpos="0" action="keep" resourceField="title"></oldColumn>
 * 		        <newColumn afterPos="0" label="CMS ID" resourceField="identifier" subField="value" type="array" nth="" maxLen="" regex=".*FHIR" default="-"></newColumn>
 * 		        <oldColumn oldPpos="1" action="keep"  resourceField="description"></oldColumn>
 * 		        <newColumn afterPos="1" label="Name" resourceField="name" subField="value" type="string" nth="" maxLen="" regex=".*FHIR" default="-"></newColumn>
 * 		        <newColumn afterPos="1" label="Start" resourceField="effectivePeriod" subField="start" type="object" nth="" maxLen="" regex=".*FHIR" default="-"></newColumn>
 * 		        <newColumn afterPos="1" label="Contact" resourceField="contact" subField="telecom" type="array" nth="first" maxLen="" regex=".*FHIR" default="-"></newColumn>
 * 		    </table-descriptor>
 * 		  </table-descriptors>	
 * }	
 *    </pre>
 *   
 *    <pre>
 * <b>generatedHTMLFile</b> Indicates the full pathname, or pathname relative to the location of the IGListChanger application, of the html file to edit. (The name 'generated-...' implies editing an html file that was generated by the IG tooling)  
 * <b>outputHTMLFfile</b> This is an optional element. If provided, then the edited html document will be written to a file with this full or relative pathname.  If not provided, the edited html document will overwrite the original file (indicated by the generatedHTMLFile pathname).  
 * <b>tagetTablePos</b> indicates the nth table in the html file to alter.  (If the file only has one table, this value should be 0)
 * <b>resourceDirectory</b> is the full pathname of the directory that holds the resource json files that were used to populate the table being altered. These resource files are used to populate any new columns added to the table.    
 * <b>oldColumn</b> is a specification of how to handle existing columns in the table. The attributes in this element dictate how the existing column is to be handled:  
 *    <b>oldPos</b> indicates the column's position in the original table.  0 = first column, 1 = second column, and so on.
 *    <b>action</b> is either <i>keep</i> or <i>remove</i>.  If 'keep', then that column and its existing data is preserved as-is in the altered table. If 'remove', then that column (and its data in the table's rows) are not included in the new, altered table.  
 *    <b>resourceField</b> is optional and refers to the json field in the resources that populate this column 
* <b>newColumn</b> is a specification of how to add a new column of data to the table. The attributes for this element dictate how the new column is to be added:
*     <b>afterPos</b> indicates the position in the row for the new column. For example, 0 means add the column after the first column in the old table, and so on. Note that if multiple new columns have the same afterPos value, then they are added to the table row in  the order they appear in the table descriptor.
*     <b>label</b> is the name of the column to show in the table header
*     <b>resourceField</b> is the field name in the json resources to retrieve when populating the column data in the table. The following attributes in the newColumn element dictate how to process the resource field data:
*     <b>type</b> indicates the type of data found in the resource field. It is one of <i>string</i>, <i>object</i> or <i>array</i>. 
*        - String fields: The field data is read as a simple string
*        - Object fields: The field data is assumed to be another json object. The subField attribute indicates which subsequent field to read from that object. The subField data is assumed to be a simple string.
*        - Array fields: The field data is assumed to be an array of simple, unnamed, json objects. The following attributes dictate how to specify which object in the array to access:
*             <b>nth</b> can be one of *first*, *last*, or a number. This means to simply get the subField data of the first, last, or nth object in the array.
*             <b>maxLen</b> If 'nth' is not specified, then maxLen is used. This is a number. The first object in the array whose subField data string length is less than the maxLen value is used.
*             <b>regex</b> If 'nth' and 'maxLen' is not specified, then regex is used. The first object in the array whose subField data string matches the regex regular expression is used.
*             <b>default</b> If 'nth', 'maxLen' and 'regex' is not specified, OR if any of those fail to return a value, then the given default value is used.
*
* </pre>
 * @author Dan Donahue
 *
 */
public class Controller {

	// Most of the following are populated by reading data from the table alteration descriptors in the control file being processed.
	// We could not use these vars, and instead just read from the file whenever we access the data. Reading the variables in locally trades storage space 
	// in favor of processing speed, and also facilitates debugging and troubleshooting.
	
	private String controlFilename = null;
	private Document controlXML = null;					// The xml file containing the descriptors describing how to change a table in 0 or more html files
	private int currDescriptorPos = 0;					// Which descriptor we are currently processing
	private Element currDescriptor = null;				// The current descriptor
	private Document htmlDoc = null;					// The actual html file (loaded as a document) that we are editing
	private Element oldTable = null;					// The table in the html file we are editing
	private Element newTable = null;					// A clone of the actual table - a version that we will physically change
	private int targetTablePos = 0;					    // Which table in the html file to edit. (The file may contain more than one table.)
	private List<String> resourceFilenames = null;		// The names of the .json resource files that we'll use to populate new columns in the table
	private List<JSONObject> resources = null;          // The corresponding list of .json documents
	private String resourceDir = null;                  // The full or relative path to the directory where the resource files are located
	private String outputHTMLFilename = null;           // The full or relative pathname of the file to write the altered html document to
	private List<Element> oldColSpecs = null;           // The list of current column specs (read from the current descriptor xml)
	
	/**
	 * Opens the control xml file of the given filename (full pathname).
	 * Initializes the process control variables used to step through the table alteration descriptors in the control file.
	 * @param filename - A string representing the pathname to a control xml file
	 */
	public Controller(String filename) {
		super();
		this.controlFilename = filename;
		this.controlXML= FileUtils.openXMLFile(filename);
		this.currDescriptorPos = -1;  // so when we call next() for the first time, current pos is set to 0.
		this.currDescriptor = null;
	}
	
	/**
	 * Advances to the next table alteration descriptor in the control file.
	 * Reads/Initializes processing data for the descriptor.
	 * If no further descriptors, return false.
	 * @return true if a next descriptor is present, false otherwise.
	 */
	public boolean next() {
		boolean isOK = true;
		this.currDescriptorPos++;
		Elements descriptors = this.controlXML.getElementsByTag("table-descriptor");
		if (this.currDescriptorPos >= descriptors.size()) {
			isOK = false;
		}
		else {
			setCurrDescriptor(descriptors.get(this.currDescriptorPos));
		}
		return isOK;
	}
	
	/**
	 * Initializes all of the processing variables in a table alteration descriptor
	 * 
	 * @param el a org.jsoup.nodes.Element representing a table-descriptor element from the control file being processed.
	 */
	public void setCurrDescriptor(Element el) {
		
		/*
		<table-descriptors>
		    <table-descriptor>
		        <generatedHTMLFile>C:\ICF-work\Dev\Measures\Ecqm-content-r4-2021\git-myFork\ecqm-content-r4-2021\output\measures.html</generated>
		        <outputHTMLFile>measures-new.html</outputHTMLFile>
		        <targetTablePos>0</targetTablePos>
		        <resourceDirectory>C:\ICF-work\Dev\Measures\Ecqm-content-r4-2021\git-myFork\ecqm-content-r4-2021\input\resources\measure</resourceDirectory>
		        <oldColumn oldPpos="0" action="keep" resourceField="title"></oldColumn>
		        <newColumn afterPos="0" label="CMS ID" resourceField="identifier" subField="value" type="array" nth="" maxLen="" regex=".*FHIR" default="-"></newColumn>
		        <oldColumn oldPpos="1" action="keep"  resourceField="description"></oldColumn>
		        <newColumn afterPos="1" label="Name" resourceField="name" subField="value" type="string" nth="" maxLen="" regex=".*FHIR" default="-"></newColumn>
		        <newColumn afterPos="1" label="Start" resourceField="effectivePeriod" subField="start" type="object" nth="" maxLen="" regex=".*FHIR" default="-"></newColumn>
		        <newColumn afterPos="1" label="Contact" resourceField="contact" subField="telecom" type="array" nth="first" maxLen="" regex=".*FHIR" default="-"></newColumn>
		    </table-descriptor>
		  </table-descriptors>		 
		  */

		this.currDescriptor = el;  // Save the current xml element
		System.out.println("\n\nProcessing " + getControlValue("generatedHTMLFile"));

		this.htmlDoc = FileUtils.parseXHtmlFile(getControlValue("generatedHTMLFile")); // open the actual html file (generated by tooling) as an html Document
		this.targetTablePos = Integer.parseInt(getControlValue("targetTablePos"));     // The actual html file may have multiple tables. This tells us which one we will alter
		this.oldTable = getTargetTable();                                              // The table element from the target html file, determined by the nth position, above
		this.newTable = this.oldTable.clone();                                              // A clone of the original table element - we will actually edit this clone.
		this.resourceDir = getControlValue("resourceDirectory");                       // where the resource files are located
		this.resourceFilenames = FileUtils.getDirFiles(this.resourceDir);                   // the list of resource filenames found in the above dir
		this.outputHTMLFilename = getControlValue("outputHTMLFile");                   // Optional name of a file to output when we finish editing. (If not present, we overwrite the original.)
		if (null == this.outputHTMLFilename) {
			this.outputHTMLFilename = getControlValue("generatedHTMLFile");
		}
		this.oldColSpecs = getOldColumnSpecs();
		this.resources = new ArrayList<JSONObject>();
		if (this.resourceFilenames != null && !this.resourceFilenames.isEmpty()) {
			for (String filename : this.resourceFilenames) {
				this.resources.add(FileUtils.parseJsonFile(this.resourceDir + "\\" + filename));
			}
		}
		else {
			System.err.println("** No resources files found at: " + this.resourceDir + "\n   Table-Descriptor Default column values will be used throughout. See " + controlFilename);
		}
	}
	
	/**
	 * Reads the text value (as a string) in the given tagname in the current table alteration descriptor
	 * 
	 * @param tagname - a string representing the tag name in a table-descriptor element to read
	 * @return a string that is the ownText() value of the given tag
	 */
	public String getControlValue(String tagname) {
		try {
			return (this.currDescriptor == null)? null : this.currDescriptor.getElementsByTag(tagname).get(0).ownText();
		}
		catch (Exception e) {
			return "";
		}
	}
	
	/**
	 * Returns all of the 'old column' specs (i.e. spec for the current columns in the html table we are editing)
	 * 
	 * @return  org.jsoup.select.Elements list of oldColumn elements
	 */
	public Elements getOldColumnSpecs() {
		return (this.currDescriptor == null)? null: this.currDescriptor.getElementsByAttribute("oldPos");

	}
	
	/**
	 * Returns all of the 'new column' specs (i.e. the specs for new columns to add to the html table we are editing)
	 * 
	 * @return org.jsoup.select.Elements list of newColumn elements
	 */
	public Elements getNewColumnSpecs() {
		return (this.currDescriptor == null)? null: this.currDescriptor.getElementsByAttribute("afterPos");

	}
	
	/**
	 * Returns all of the 'new column' specs to be added after the given column position (i.e. the specs for new columns to add to the html table we are editing)
	 * 
	 * @param pos - a number (as a String)
	 * @return org.jsoup.select.Elements list of newColumn elements
	 */
	public Elements getNewColumnSpecs(String pos) {
		return (this.currDescriptor == null)? null: this.currDescriptor.getElementsByAttributeValue("afterPos", pos);

	}
	

	/**
	 * Using the targetTablePos item from the current descriptor, return the nth html table from the file, where n is the targetTablePos
	 * 
	 * @return org.jsoup.nodes.Element object that is an html table from the current html document being processed
	 */
	public Element getTargetTable() {
		Element table = null;
		if (this.htmlDoc != null) {
			table = this.htmlDoc.getElementsByTag("table").get(this.targetTablePos);
		}
		return table;
	}
	
	/**
	 * Using the data from the current table alteration descriptor, re-generate the target table's header info
	 * by copying existing columns from the original table to a new table, and by creating new columns
	 * based on the new-cols specs from the descriptor.
	 */
	public void processTableHeader() {
		Element header = this.oldTable.getElementsByTag("thead").get(0);   // Assumes the source table we are working with has a single header element.
		Element newHeader = header.clone();                                // Clone the header, and empty the clone's children
		newHeader.empty();
		Element row = header.getElementsByTag("tr").get(0);
		Element newRow = row.clone();                                      // Get the single row (<tr>) from the source table header
		newRow.empty();                                                    // Empty the clone row's children. (We'll re-populate from the source, with changes.)
		Elements oldCols = row.getElementsByTag("th");                     // Get the header column elements from the source
		for (int i = 0; i < oldCols.size(); i++ ) {                        // For each header column, if we want to keep the column, copy/clone from the source to the new header row.
			Element oldCol = oldCols.get(i);
			Element oldColSpec = this.oldColSpecs.get(i);
			if ("keep".equalsIgnoreCase(oldColSpec.attr("action"))) {
				System.out.println("    Keeping column " + i + ", " + oldCol.ownText());
				Element newCol = oldCol.clone();
				newRow.appendChild(newCol);	
			}
			else if ("remove".equalsIgnoreCase(oldColSpec.attr("action"))) {
				System.out.println("    Removing column " + i + ", " + oldCol.ownText());
			}
			Elements newCols = getNewColumnSpecs(String.format("%d", i));
			for (Element newColSpec : newCols) {                     // Now see if there are any new columns to add after the current column position we are working on (via the after-pos column specs)
				System.out.println("    Adding column: " +   newColSpec.toString());
				newRow.appendElement("th").text(newColSpec.attr("label"));
			}
			
		}
		this.newTable.empty();                                       // Clear the new table element
		newHeader.appendChild(newRow);                               // Add the new row to the new header
		this.newTable.appendChild(newHeader);                        // Add the new header to the new table
		//System.out.println("\n\n" + this.newTable + "\n\n");
		
	}
	
	/**
	 * Using the data from the current table alteration descriptor, re-generate the target table's rows
	 * by copying existing row columns from the original table to a new table, and by creating new row columns
	 * based on the new-cols specs from the descriptor, and populating those new columns with data from
	 * the corresponding resource json object based on the new-column spec data for each new column.
	 */
	public void processTableRows() {
		Element body = this.oldTable.getElementsByTag("tbody").get(0);   // Assumes the source table we are working with has a single tbody element.
		Element newBody = body.clone();                                  // Clone the body, and empty the clone's children
		newBody.empty();
		Elements rows = body.getElementsByTag("tr");                     // Now cycle through each row of the source table...
		for (int r=0; r < rows.size(); r++) {
		    Element row = rows.get(r);
			Element newRow = row.clone();   
			newRow.empty();                                              // Clone the row, then empty the clone row's children. (We'll re-populate from the source, with changes.)       
			Elements oldCols = row.getElementsByTag("td");  
			//System.out.println("Row " + r + ": " +oldCols.size());
		    JSONObject resource = this.resources.isEmpty() ? null : this.resources.get(r);  // Get the corresponding resource for this row. ASSUMPTION: The resource list is one-to-one with the rows in the table, in the same order.

			for (int i = 0; i < oldCols.size(); i++ ) {                  // For each column in the source row, if we want to keep the column, copy/clone from the source to the new row.       
				Element oldCol = oldCols.get(i);
				Element oldColSpec = this.oldColSpecs.get(i);
				if ("keep".equalsIgnoreCase(oldColSpec.attr("action"))) {
					//System.out.println("Keeping col " + i + ", " + oldCol.ownText());
					Element newCol = oldCol.clone();
					newRow.appendChild(newCol);	
				}
				Elements newCols = getNewColumnSpecs(String.format("%d", i));
				for (Element newColSpec : newCols) {                     // Now see if there are any new columns to add after the current column position we are working on (via the after-pos column specs)
					String fieldVal = getResourceFieldValue(resource, newColSpec);
					newRow.appendElement("td").text(fieldVal);
				}
				
			}
			newBody.appendChild(newRow);                                 // Add this new row to the new body
		}
		this.newTable.appendChild(newBody);                              // Add the new body to the new table
		System.out.println("\n\nNew Table:\n" + this.newTable + "\n\n");
		
	}
	
	/**
	 * Return the json field value in the given json resource using the attribute data within the given colSpec object to determine how
	 * to get the data from the resource
	 * 
	 * @param resource a JSONObject representing the JSON data read from a resource file
	 * @param colSpec a newCol org.jsoup.nodes.Element 
	 * @return String representing a field value from the JSON resource, as interpreted by the given colSpec
	 */
	public String getResourceFieldValue(JSONObject resource, Element colSpec) {
		// <newColumn after-pos="0" label="CMS ID" resource-field="identifier" type="string|array|object"  nth="0" maxLen="15" subField="" regex="" default="-"></newColumn>
		
		// Read the column spec data into local variables. (Probably overkill, but makes things easier during debugging.)
		String val = colSpec.attr("default");            // The default value (from the spec) will be returned if nothing else works out
		String field = colSpec.attr("resourceField");    // The name of the field in the json resource to get
		String subField = colSpec.attr("subField");      // If the field is something other than a pure string, this is the name of the subsequent field to get
		String fType = colSpec.attr("type");             // The 'type' of the field we are getting. Can be one of  string, object, or array
		String nth = colSpec.attr("nth");                // Referring to which element in a field's array to get
		String maxLenStr = colSpec.attr("maxLen");       // Referring to a maximum length of a subfield in a field's array objects to consider
		Integer maxLen = -1;
		String regex = colSpec.attr("regex");            // Referring to a pattern to examine for the subfield in a fields' array of objects to consider
		JSONObject obj = null;
		
		if (resource == null) {
			return val;
		}
		
		// Though not  necessarily needed in all cases, go ahead and parse the maxLen attribute now.
		try {
			maxLen = Integer.parseInt(maxLenStr);
		}
		catch (Exception e) {
			maxLen = -1;
		}
		
		// Depending on the type of data in the field value, we do different things...
		switch (fType) {
			case "string" : // For simple string values, just return that value
				try {
					val =  resource.get(field).toString(); 
				}
				catch (Exception e) {
					System.err.println("String field error: " + e.getMessage() + "\n    Spec: " + colSpec);
				}
				 break;
			case "object" : // If the field value is an object, return the subfield value within that object
				try {
					obj = resource.getJSONObject(field);
					val =  obj.get(subField).toString();
				}
				catch (Exception e) {
					System.err.println("Object field error: " + e.getMessage() + "\n    Spec: " + colSpec);
					// problem, move on
				}
				break;
			case "array" :  // If the field is an array of json objects, the other colSpec attributes dictate which object in that array to use...
				JSONArray vals = resource.getJSONArray(field);
				//  Return the subfield value of the first array object...
				if ("first".equalsIgnoreCase(nth)) {
					try {
						obj = vals.getJSONObject(0);
						val = obj.get(subField).toString();
					}
					catch (Exception e) {
						System.err.println("Array[first] field error: " + e.getMessage() + "\n    Spec: " + colSpec);
						// problem, move on
					}
				}
				// Return the subfield value of the last array object...
				else if ("last".equalsIgnoreCase(nth)) {
					try {
						obj = vals.getJSONObject(vals.length()-1);
						val =  obj.get(subField).toString();
					}
					catch (Exception e) {
						System.err.println("Array[last] field error: " + e.getMessage() + "\n    Spec: " + colSpec);
						// problem, move on
					}
				}
				// Return the subfield value of the nth array object...
				else if (!nth.isEmpty()) {
					try {
						int n = Integer.parseInt(nth);
						obj = vals.getJSONObject(n);
						val =  obj.get(subField).toString();
					}
					catch (Exception e) {
						System.err.println("Array[nth] field error: " + e.getMessage() + "\n    Spec: " + colSpec);
						// Obviously, the value of nth isn't an integer, so do nothing.
					}
				}
				// Return the subfield value of the first array object whose subfield value length is less than or equal to the given max length value
				else if (maxLen >= 0) {
						String temp = null;
						for (int i=0; i < vals.length(); i++) {
							try {
								obj = vals.getJSONObject(i);
							    temp =  obj.get(subField).toString();
							
								if (maxLen >= temp.length()) {
									val = temp;
									break;
								}
							}
							catch (Exception e) {
								System.err.println("Array[maxLen] field error: " + e.getMessage() + "\n    Spec: " + colSpec);
								// failed seeing if the object's subField was a string of a given length, so do nothing, and on to the next obj in the array.
							}
						}
				}
				// Return the subfield value of the first array object whose subfield value matches the given regex
				else if (!regex.isEmpty()) {
						String temp = null;
						for (int i=0; i < vals.length(); i++) {
							try {
								obj = vals.getJSONObject(i);
								temp =  obj.get(subField).toString();
								if (Pattern.matches(regex, temp)) {
									val = temp;
									break;
								}
							}
							catch (Exception e) {
								System.err.println("Array[regex] field error: " + e.getMessage() + "\n    Spec: " + colSpec);
								// failed seeing if the object's subField was a string that matches the regex, so do nothing, and on to the next obj in the array.
							}
						}
				}
			 break;
		}
		return val; // Note: if none of the cases above fired, then val is still set to the colSpec's default value
	}
	
	/**
	 * Replace the oldTable element in the original html document with the newTable element (that we've built in the processTableHeader() and processTableRows() methods).
	 */
	public void updateOriginalDocument() {
		this.oldTable.replaceWith(this.newTable);
		writeHTMLFile(this.htmlDoc);
	}
	
	/**
	 * Write the html document to the (full path) outputHTMLFilename as specified in the current table alteration descriptor.
	 * Note: If no outputHTMLFilename value is provided in the descriptor, the html document is written to the original html file.
	 * 
	 * @param doc - org.jsoup.nodes.Document representing the html file being processed
	 * @return true if the write operation was successful, false otherwise.
	 */
	public boolean writeHTMLFile(Document doc) {
		System.out.println("Writing document to: " +this.outputHTMLFilename );
		return FileUtils.writeXHtmlFile(doc, this.outputHTMLFilename);
	}
}
