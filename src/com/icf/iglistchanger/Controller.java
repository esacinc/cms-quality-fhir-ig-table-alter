package com.icf.iglistchanger;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

import org.json.JSONArray;
import org.json.JSONObject;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;


public class Controller {

	// Most of the following are populated by reading data from the table alteration descriptors in the control file being processed.
	// We could not use these vars, and instead just read from the file whenever we access the data. Reading the variables in locally trades storage space 
	// in favor of processing speed, and also facilitates debugging and troubleshooting.
	
	private String controlFilename = null;
	private Document controlXML = null;					// The xml file containing the descriptors describing how to change a table in 0 or more html files
	private int currDescriptorPos = 0;					// Which descriptor we are currently processing
	private Element currDescriptor = null;				// The current descriptor
	private Document htmlDoc = null;					// The actual html file (loaded as a document) that we are editing
	private Element oldTable = null;					// The table in the html file we are editing
	private Element newTable = null;					// A clone of the actual table - a version that we will physically change
	private int targetTablePos = 0;					    // Which table in the html file to edit. (The file may contain more than one table.)
	private List<String> resourceFilenames = null;		// The names of the .json resource files that we'll use to populate new columns in the table
	private List<JSONObject> resources = null;          // The corresponding list of .json documents
	private String resourceDir = null;                  // The full or relative path to the directory where the resource files are located
	private String outputHTMLFilename = null;           // The full or relative pathname of the file to write the altered html document to
	private List<Element> oldColSpecs = null;           // The list of current column specs (read from the current descriptor xml)
	private List<Element> newColSpecs = null;           // The list of new columns to add (specs read from the current descriptor xml)
	
	/**
	 * Opens the control xml file of the given filename (full pathname).
	 * Initializes the process control variables used to step through the table alteration descriptors in the control file.
	 * @param filename
	 */
	public Controller(String filename) {
		super();
		controlFilename = filename;
		controlXML= FileUtils.openXMLFile(filename);
		currDescriptorPos = -1;  // so when we call next() for the first time, current pos is set to 0.
		currDescriptor = null;
	}
	
	/**
	 * Advances to the next table alteration descriptor in the control file.
	 * Reads/Initializes processing data for the descriptor.
	 * If no further descriptors, return false.
	 * @return true if a next descriptor is present, false otherwise.
	 */
	public boolean next() {
		boolean isOK = true;
		currDescriptorPos++;
		Elements descriptors = controlXML.getElementsByTag("table-descriptor");
		if (currDescriptorPos >= descriptors.size()) {
			isOK = false;
		}
		else {
			setCurrDescriptor(descriptors.get(currDescriptorPos));
		}
		return isOK;
	}
	
	/**
	 * Initializes all of the processing variables in a table alteration descriptor
	 * @param el
	 */
	public void setCurrDescriptor(Element el) {
		
		/*
		<table-descriptors>
		    <table-descriptor>
		        <generatedHTMLFile>C:\ICF-work\Dev\Measures\Ecqm-content-r4-2021\git-myFork\ecqm-content-r4-2021\output\measures.html</generated>
		        <outputHTMLFile>measures-new.html</outputHTMLFile>
		        <targetTablePos>0</targetTablePos>
		        <resourceDirectory>C:\ICF-work\Dev\Measures\Ecqm-content-r4-2021\git-myFork\ecqm-content-r4-2021\input\resources\measure</resourceDirectory>
		        <oldColumn oldPpos="0" action="keep" resourceField="title"></oldColumn>
		        <newColumn afterPos="0" label="CMS ID" resourceField="identifier" subField="value" type="array" nth="" maxLen="" regex=".*FHIR" default="-"></newColumn>
		        <oldColumn oldPpos="1" action="keep"  resourceField="description"></oldColumn>
		        <newColumn afterPos="1" label="Name" resourceField="name" subField="value" type="string" nth="" maxLen="" regex=".*FHIR" default="-"></newColumn>
		        <newColumn afterPos="1" label="Start" resourceField="effectivePeriod" subField="start" type="object" nth="" maxLen="" regex=".*FHIR" default="-"></newColumn>
		        <newColumn afterPos="1" label="Contact" resourceField="contact" subField="telecom" type="array" nth="first" maxLen="" regex=".*FHIR" default="-"></newColumn>
		    </table-descriptor>
		  </table-descriptors>		 
		  */

		currDescriptor = el;  // Save the current xml element
		System.out.println("\n\nProcessing " + getControlValue("generatedHTMLFile"));

		htmlDoc = FileUtils.parseXHtmlFile(getControlValue("generatedHTMLFile")); // open the actual html file (generated by tooling) as an html Document
		targetTablePos = Integer.parseInt(getControlValue("targetTablePos"));     // The actual html file may have multiple tables. This tells us which one we will alter
		oldTable = getTargetTable();                                              // The table element from the target html file, determined by the nth position, above
		newTable = oldTable.clone();                                              // A clone of the original table element - we will actually edit this clone.
		resourceDir = getControlValue("resourceDirectory");                       // where the resource files are located
		resourceFilenames = FileUtils.getDirFiles(resourceDir);                   // the list of resource filenames found in the above dir
		outputHTMLFilename = getControlValue("outputHTMLFile");                   // Optional name of a file to output when we finish editing. (If not present, we overwrite the original.)
		if (null == outputHTMLFilename) {
			outputHTMLFilename = getControlValue("generatedHTMLFile");
		}
		oldColSpecs = getOldColumnSpecs();
		newColSpecs = getNewColumnSpecs();
		resources = new ArrayList<JSONObject>();
		if (resourceFilenames != null && !resourceFilenames.isEmpty()) {
			for (String filename : resourceFilenames) {
				resources.add(FileUtils.parseJsonFile(resourceDir + "\\" + filename));
			}
		}
		else {
			System.err.println("** No resources files found at: " + resourceDir + "\n   Table-Descriptor Default column values will be used throughout. See " + controlFilename);
		}
	}
	
	/**
	 * Reads the text value (as a string) in the given tagname in the current table alteration descriptor
	 * @param tagname
	 * @return
	 */
	public String getControlValue(String tagname) {
		try {
			return (currDescriptor == null)? null : currDescriptor.getElementsByTag(tagname).get(0).ownText();
		}
		catch (Exception e) {
			return "";
		}
	}
	
	/**
	 * Returns all of the 'old column' specs (i.e. spec for the current columns in the html table we are editing)
	 * @return
	 */
	public Elements getOldColumnSpecs() {
		return (currDescriptor == null)? null: currDescriptor.getElementsByAttribute("oldPos");

	}
	
	/**
	 * Returns all of the 'new column' specs (i.e. the specs for new columns to add to the html table we are editing)
	 * @return
	 */
	public Elements getNewColumnSpecs() {
		return (currDescriptor == null)? null: currDescriptor.getElementsByAttribute("afterPos");

	}
	
	/**
	 * Returns all of the 'new column' specs to be added after the given column position (i.e. the specs for new columns to add to the html table we are editing)
	 * @return
	 */
	public Elements getNewColumnSpecs(String pos) {
		return (currDescriptor == null)? null: currDescriptor.getElementsByAttributeValue("afterPos", pos);

	}
	

	/**
	 * Using the targetTablePos item from the current descriptor, return the nth html table from the file, where n is the targetTablePos
	 * @return
	 */
	public Element getTargetTable() {
		Element table = null;
		if (htmlDoc != null) {
			table = htmlDoc.getElementsByTag("table").get(targetTablePos);
		}
		return table;
	}
	
	/**
	 * Using the data from the current table alteration descriptor, re-generate the target table's header info
	 * by copying existing columns from the original table to a new table, and by creating new columns
	 * based on the new-cols specs from the descriptor.
	 */
	public void processTableHeader() {
		Element header = oldTable.getElementsByTag("thead").get(0);   // Assumes the source table we are working with has a single header element.
		Element newHeader = header.clone();                           // Clone the header, and empty the clone's children
		newHeader.empty();
		Element row = header.getElementsByTag("tr").get(0);
		Element newRow = row.clone();                                 // Get the single row (<tr>) from the source table header
		newRow.empty();                                               // Empty the clone row's children. (We'll re-populate from the source, with changes.)
		Elements oldCols = row.getElementsByTag("th");                // Get the header column elements from the source
		for (int i = 0; i < oldCols.size(); i++ ) {                   // For each header column, if we want to keep the column, copy/clone from the source to the new header row.
			Element oldCol = oldCols.get(i);
			Element oldColSpec = oldColSpecs.get(i);
			if ("keep".equalsIgnoreCase(oldColSpec.attr("action"))) {
				System.out.println("    Keeping column " + i + ", " + oldCol.ownText());
				Element newCol = oldCol.clone();
				newRow.appendChild(newCol);	
			}
			else if ("remove".equalsIgnoreCase(oldColSpec.attr("action"))) {
				System.out.println("    Removing column " + i + ", " + oldCol.ownText());
			}
			Elements newCols = getNewColumnSpecs(String.format("%d", i));
			for (Element newColSpec : newCols) {                 // Now see if there are any new columns to add after the current column position we are working on (via the after-pos column specs)
				System.out.println("    Adding column: " +   newColSpec.toString());
				newRow.appendElement("th").text(newColSpec.attr("label"));
			}
			
		}
		newTable.empty();                                            // Clear the new table element
		newHeader.appendChild(newRow);                               // Add the new row to the new header
		newTable.appendChild(newHeader);                             // Add the new header to the new table
		//System.out.println("\n\n" + newTable + "\n\n");
		
	}
	
	/**
	 * Using the data from the current table alteration descriptor, re-generate the target table's rows
	 * by copying existing row columns from the original table to a new table, and by creating new row columns
	 * based on the new-cols specs from the descriptor, and populating those new columns with data from
	 * the corresponding resource json object based on the new-column spec data for each new column.
	 */
	public void processTableRows() {
		Element body = oldTable.getElementsByTag("tbody").get(0);   // Assumes the source table we are working with has a single tbody element.
		Element newBody = body.clone();                             // Clone the body, and empty the clone's children
		newBody.empty();
		Elements rows = body.getElementsByTag("tr");                // Now cycle through each row of the source table...
		for (int r=0; r < rows.size(); r++) {
		    Element row = rows.get(r);
			Element newRow = row.clone();   
			newRow.empty();                                        // Clone the row, then empty the clone row's children. (We'll re-populate from the source, with changes.)       
			Elements oldCols = row.getElementsByTag("td");  
			//System.out.println("Row " + r + ": " +oldCols.size());
		    JSONObject resource = resources.isEmpty() ? null : resources.get(r);  // Get the corresponding resource for this row. ASSUMPTION: The resource list is one-to-one with the rows in the table, in the same order.

			for (int i = 0; i < oldCols.size(); i++ ) {            // For each column in the source row, if we want to keep the column, copy/clone from the source to the new row.       
				Element oldCol = oldCols.get(i);
				Element oldColSpec = oldColSpecs.get(i);
				if ("keep".equalsIgnoreCase(oldColSpec.attr("action"))) {
					//System.out.println("Keeping col " + i + ", " + oldCol.ownText());
					Element newCol = oldCol.clone();
					newRow.appendChild(newCol);	
				}
				Elements newCols = getNewColumnSpecs(String.format("%d", i));
				for (Element newColSpec : newCols) {                 // Now see if there are any new columns to add after the current column position we are working on (via the after-pos column specs)
					String fieldVal = getResourceFieldValue(resource, newColSpec);
					newRow.appendElement("td").text(fieldVal);
				}
				
			}
			newBody.appendChild(newRow);                             // Add this new row to the new body
		}
		newTable.appendChild(newBody);                               // Add the new body to the new table
		System.out.println("\n\nNew Table:\n" + newTable + "\n\n");
		
	}
	
	/**
	 * Return the json field value in the given json resource using the attribute data within the given colSpec object to determine how
	 * to get the data from the resource
	 * @param resource
	 * @param colSpec
	 * @return
	 */
	public String getResourceFieldValue(JSONObject resource, Element colSpec) {
		// <newColumn after-pos="0" label="CMS ID" resource-field="identifier" type="string|array|object"  nth="0" maxLen="15" subField="" regex="" default="-"></newColumn>
		
		// Read the column spec data into local variables. (Probably overkill, but makes things easier during debugging.)
		String val = colSpec.attr("default");            // The default value (from the spec) will be returned if nothing else works out
		String field = colSpec.attr("resourceField");   // The name of the field in the json resource to get
		String subField = colSpec.attr("subField");      // If the field is something other than a pure string, this is the name of the subsequent field to get
		String fType = colSpec.attr("type");             // The 'type' of the field we are getting. Can be one of  string, object, or array
		String nth = colSpec.attr("nth");                // Referring to which element in a field's array to get
		String maxLenStr = colSpec.attr("maxLen");       // Referring to a maximum length of a subfield in a field's array objects to consider
		Integer maxLen = -1;
		String regex = colSpec.attr("regex");            // Referring to a pattern to examine for the subfield in a fields' array of objects to consider
		JSONObject obj = null;
		
		if (resource == null) {
			return val;
		}
		
		// Though not  necessarily needed in all cases, go ahead and parse the maxLen attribute now.
		try {
			maxLen = Integer.parseInt(maxLenStr);
		}
		catch (Exception e) {
			maxLen = -1;
		}
		
		// Depending on the type of data in the field value, we do different things...
		switch (fType) {
			case "string" : // For simple string values, just return that value
				try {
					val =  resource.get(field).toString(); 
				}
				catch (Exception e) {
					System.err.println("String field error: " + e.getMessage() + "\n    Spec: " + colSpec);
				}
				 break;
			case "object" : // If the field value is an object, return the subfield value within that object
				try {
					obj = resource.getJSONObject(field);
					val =  obj.get(subField).toString();
				}
				catch (Exception e) {
					System.err.println("Object field error: " + e.getMessage() + "\n    Spec: " + colSpec);
					// problem, move on
				}
				break;
			case "array" :  // If the field is an array of json objects, the other colSpec attributes dictate which object in that array to use...
				JSONArray vals = resource.getJSONArray(field);
				//  Return the subfield value of the first array object...
				if ("first".equalsIgnoreCase(nth)) {
					try {
						obj = vals.getJSONObject(0);
						val = obj.get(subField).toString();
					}
					catch (Exception e) {
						System.err.println("Array[first] field error: " + e.getMessage() + "\n    Spec: " + colSpec);
						// problem, move on
					}
				}
				// Return the subfield value of the last array object...
				else if ("last".equalsIgnoreCase(nth)) {
					try {
						obj = vals.getJSONObject(vals.length()-1);
						val =  obj.get(subField).toString();
					}
					catch (Exception e) {
						System.err.println("Array[last] field error: " + e.getMessage() + "\n    Spec: " + colSpec);
						// problem, move on
					}
				}
				// Return the subfield value of the nth array object...
				else if (!nth.isEmpty()) {
					try {
						int n = Integer.parseInt(nth);
						obj = vals.getJSONObject(n);
						val =  obj.get(subField).toString();
					}
					catch (Exception e) {
						System.err.println("Array[nth] field error: " + e.getMessage() + "\n    Spec: " + colSpec);
						// Obviously, the value of nth isn't an integer, so do nothing.
					}
				}
				// Return the subfield value of the first array object whose subfield value length is less than or equal to the given max length value
				else if (maxLen >= 0) {
						String temp = null;
						for (int i=0; i < vals.length(); i++) {
							try {
								obj = vals.getJSONObject(i);
							    temp =  obj.get(subField).toString();
							
								if (maxLen >= temp.length()) {
									val = temp;
									break;
								}
							}
							catch (Exception e) {
								System.err.println("Array[maxLen] field error: " + e.getMessage() + "\n    Spec: " + colSpec);
								// failed seeing if the object's subField was a string of a given length, so do nothing, and on to the next obj in the array.
							}
						}
				}
				// Return the subfield value of the first array object whose subfield value matches the given regex
				else if (!regex.isEmpty()) {
						String temp = null;
						for (int i=0; i < vals.length(); i++) {
							try {
								obj = vals.getJSONObject(i);
								temp =  obj.get(subField).toString();
								if (Pattern.matches(regex, temp)) {
									val = temp;
									break;
								}
							}
							catch (Exception e) {
								System.err.println("Array[regex] field error: " + e.getMessage() + "\n    Spec: " + colSpec);
								// failed seeing if the object's subField was a string that matches the regex, so do nothing, and on to the next obj in the array.
							}
						}
				}
			 break;
		}
		return val; // Note: if none of the cases above fired, then val is still set to the colSpec's default value
	}
	
	/**
	 * Replace the oldTable element in the original html document with the newTable element (that we've built in the processTableHeader() and processTableRows() methods).
	 */
	public void updateOriginalDocument() {
		oldTable.replaceWith(newTable);
		writeHTMLFile(htmlDoc);
	}
	
	/**
	 * Write the html document to the (full path) outputHTMLFilename as specified in the current table alteration descriptor.
	 * Note: If no outputHTMLFilename value is provided in the descriptor, the html document is written to the original html file.
	 * @param doc
	 * @return
	 */
	public boolean writeHTMLFile(Document doc) {
		System.out.println("Writing document to: " +outputHTMLFilename );
		return FileUtils.writeXHtmlFile(doc, outputHTMLFilename);
	}
}
